
Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more


Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

Document
version
: v1.0
CS342  Operating Systems
–
Spring 2018
Project 2:
Multi
-
threaded Server, Shared Memory and Synchronization
Assigned
: March
14
, 2018
Due date
:
April 4
, 2018,
23:55
(Moodle)
(no deadline extension will be g
r
anted)
You can do this project as a group of two students each. You have to program in C
on Linux
. You are required to use the following distribution of Linux: Ubuntu 16.04
–
64 bit. Because this will be our test environment
.
Objective
s
: Practice
d
evelop
i
n
g
multi
ple
-
threaded applications,
practice
inter
-
process
communication (IPC) via
shared memory,
practice solving
synchronization
problems
,
and
practice use of
semaphores.
In  this project you will implement a multi
-
threaded server that will process keyword
search queries from clients. You will implement both the server program and the
client  program.  Multiple  clients  can  request  service  from  the  server  concurrently.
The service given will be a keyword search service. Upon receiving a keyword from a
client,
the server will search  the keyword in an input text file and will send back the
line  numbers  of  the  lines  having  the  keyword  at  least  once  (i.e.,  line  numbers  of
matching  lines).  Inter
-
process  communication  between  clients  and  server  will  be
achieved  via
shared  memory.  For  each  client,  the  server  will  create  a  thread  to
hand
le
the request of the client. The client program will just send one request and
will wait for the results to arrive. Then it will write the results to the screen and will
terminate.  Sev
eral  client  processes  can    be  started  concurrently  to  run  in  the
background using the & sign, or by use of a different Linux terminal window for each
different client.
The server program will be called “server” and will take the following
parameters.
s
erver  <shm_name> <
in
put
filename> <sem_name>
<shm_name> is the name of the shared memory segment that will be created by the
server and that will be used by the clients and server to share
data
and communicate
with each other. The name of the shared segme
nt is just a filename (for example
/mysharedsegment). <
input
filename> is the name of an input text file (ascii) which
will be searched upon receiving a request (query) from a client. <sem_name> is a
prefix
for naming your semaphores.
When started, server
program will first create a shared memory segment of enough
size and will initialize it. The segment will contain shared data. The shared data will
include  a  request  queue  (to  send  requests  from  cli
ents  to  server),  several  result
(data) queues (to send  r
esults from worker threads of the server to the respective
clients) and some other data structures or variables necessary to solve this problem.
There  can  be  at  most  N
clients  running  concurre
ntly.  Therefore,    there  will  be
N
result  queues  in  the  shared
segment:  one  queue  per
possible
client.  Each
active
2
client  will  use  a
separate  result
queue.  An  additional  data  structure  in  shared
memory  can  be  used  to  keep  information  about  the  state  of  the  queues.  This
structure  can  be,  for  example,  an  array  of  N  elements,  where  each  element  may
indicate if the corresponding
result
queue is used or no
t.  The element type can be
integer. Let use call this array as queue_state. Initially it will be all zeros
(no queue is
used yet)
.
The  client  program  will  be  a  single  threaded  program  and  will  take  the  following
parameters.
client <shm_name> <keyword
> <sem_name>
<shm_name>  is  the  name  of  the  shared  memory  segment  created  by  the  server.
Client will use it to access shared data and to communicate with the server (send a
request  and  get  the  results).  <keyword>  is  an  alphanumeric  string  (including  just
u
ppercase and lowercase letters and digits) that will be searched at the server side in
the input file that the server has access to. A client can not search the file directly;
the server process will search it. When started, the client will first open the
shared
memory segment and will get ready to access it. Then it may access the queue_state
array in the shared memory and try to find a queue that is unused at the moment.
Make  sure  you  lock  (by  use  of  a  semaphore)
queue_state  array  while  you
are
searching
and modifying it.  If there is no unused queue at the moment,  the client
will terminate after printing an error message like “too many clients started”. This
will happen if there are already N clients started and running concurrently.
Server
can handle
a
t most
N clients concurrently.
If the client can find an unused
result
queue while searching the queue_state array, the client will mark the corresponding
entry in the queue_state array as “used” and will record the index of that entry. This
is the index
o
f the queue that is unused. It
will be
used
by the client to retrieve the
results. The client needs to send this index information to the server
as well
. You can
assume result queues have
indices
like 0, 1, ...N
-
1.
Then, the client will generate a reques
t (
a structure
) that will includ
e two fields: the
keyword
taken from
the
command line
and
the
index of the
selected
unused
queue.
The client will put the request into the request queue in the shared memory.
This is
like
putting an
item
into a bounded buffer.
This queue is a c
ircular
bounded
buffer.
The  size  of
the
request  queue  can  be  N
or  more

